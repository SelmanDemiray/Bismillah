<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Command Center</title>
    <style>
        :root {
            --primary: #00d4ff;
            --secondary: #ff0080;
            --success: #00ff88;
            --error: #ff3838;
            --warning: #ffa500;
            --bg-dark: #0a0a12;
            --bg-panel: rgba(15, 15, 25, 0.9);
            --text: #e8e8f0;
            --text-muted: #8888a8;
            --border: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
            padding-bottom: 60px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .header .subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
        }

        .card.full-width {
            grid-column: 1 / -1;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .card-header h2 {
            font-size: 1.25rem;
            color: var(--primary);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-family: inherit;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        textarea {
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 300px;
        }

        button {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
        }

        button:hover:not(:disabled) {
            background: var(--primary);
            color: var(--bg-dark);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-secondary {
            border-color: var(--text-muted);
            color: var(--text-muted);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--text-muted);
            color: var(--bg-dark);
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .layer-list {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }

        .layer-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            color: var(--primary);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .layer-params {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            font-size: 0.85rem;
        }

        .layer-params input {
            width: 70px;
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }

        .remove-btn {
            background: transparent;
            border: none;
            color: var(--error);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 0.5rem;
            line-height: 1;
        }

        .graph-visual {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1.5rem;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: auto;
        }

        .graph-nodes {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .graph-node {
            background: var(--bg-panel);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 1rem;
            min-width: 120px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
        }

        .node-connector {
            width: 30px;
            height: 2px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
        }

        .logs {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .log-entry {
            margin-bottom: 0.25rem;
        }

        .log-success { color: var(--success); }
        .log-error { color: var(--error); }
        .log-info { color: var(--primary); }

        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 0.75rem 1rem;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 1000;
            transition: all 0.3s;
        }

        .status-bar.success {
            background: rgba(0, 255, 136, 0.15);
            border-color: var(--success);
        }

        .status-bar.error {
            background: rgba(255, 56, 56, 0.15);
            border-color: var(--error);
        }

        canvas {
            width: 100%;
            height: 200px;
            border-radius: 6px;
        }

        .add-layer-controls {
            display: flex;
            gap: 0.5rem;
        }

        .add-layer-controls select {
            flex: 1;
        }

        .icon {
            width: 20px;
            height: 20px;
            display: inline-block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸš€ Neural Network Command Center</h1>
            <p class="subtitle">Design, Train, and Deploy Deep Learning Models</p>
        </div>

        <div class="grid">
            <div class="card full-width">
                <div class="card-header">
                    <h2>Architecture Designer</h2>
                </div>
                
                <div class="form-group">
                    <label>Load Template</label>
                    <div class="template-grid">
                        <button class="btn-secondary" onclick="app.loadTemplate('mlp')">MLP</button>
                        <button class="btn-secondary" onclick="app.loadTemplate('transformer_block')">Transformer</button>
                        <button class="btn-secondary" onclick="app.loadTemplate('autoencoder')">Autoencoder</button>
                    </div>
                </div>

                <div class="form-group">
                    <label>Add Layer</label>
                    <div class="add-layer-controls">
                        <select id="add-layer-type">
                            <option value="Linear">Linear</option>
                            <option value="ReLU">ReLU</option>
                            <option value="Gelu">Gelu</option>
                            <option value="Sigmoid">Sigmoid</option>
                            <option value="Softmax">Softmax</option>
                            <option value="LayerNorm">LayerNorm</option>
                        </select>
                        <button onclick="app.addLayer()">Add Layer</button>
                    </div>
                </div>

                <div class="form-group">
                    <label>Current Architecture</label>
                    <div class="layer-list" id="layer-list"></div>
                </div>

                <div class="form-group">
                    <label>Visual Graph</label>
                    <div class="graph-visual">
                        <div class="graph-nodes" id="graph-nodes"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h2>Model Configuration (JSON)</h2>
                </div>
                <div class="form-group">
                    <textarea id="model-config" readonly></textarea>
                </div>
                <button id="create-model-btn" onclick="app.createModel()">Create Model</button>
            </div>

            <div class="card">
                <div class="card-header">
                    <h2>Training Controls</h2>
                </div>
                
                <div class="form-group">
                    <label>Select Model</label>
                    <select id="selected-model">
                        <option value="">No models available</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Epochs</label>
                    <input type="number" id="epochs" value="50" min="1">
                </div>

                <div class="form-group">
                    <label>Batch Size</label>
                    <input type="number" id="batch-size" value="32" min="1">
                </div>

                <div class="form-group">
                    <label>Learning Rate</label>
                    <input type="number" id="learning-rate" value="0.01" step="0.001" min="0.0001">
                </div>

                <button id="train-btn" onclick="app.startTraining()">Start Training</button>
            </div>

            <div class="card full-width">
                <div class="card-header">
                    <h2>System Monitor</h2>
                </div>
                <canvas id="loss-graph"></canvas>
                <div class="logs" id="logs"></div>
            </div>
        </div>
    </div>

    <div class="status-bar" id="status-bar">
        <span id="status-text">Ready</span>
        <span id="status-detail"></span>
    </div>

    <script>
        const API_BASE = window.location.hostname === 'localhost' 
            ? 'http://localhost:8080' 
            : `http://${window.location.hostname}:8080`;

        const state = {
            models: [],
            architecture: { layers: [] },
            isRequestPending: false,
        };

        const app = {
            async initialize() {
                this.log('System initialized', 'info');
                this.loadTemplate('mlp');
                await this.checkBackendHealth();
                await this.updateAvailableModels();
            },

            async checkBackendHealth() {
                try {
                    const response = await fetch(`${API_BASE}/health`);
                    const data = await response.json();
                    if (data.status === 'success') {
                        this.log('Backend connection established', 'success');
                        this.showStatus('Connected to backend', 'success', 3000);
                    }
                } catch (error) {
                    this.log(`Backend connection failed: ${error.message}`, 'error');
                    this.showStatus('Cannot connect to backend - is it running?', 'error', 0);
                }
            },

            addLayer() {
                if (state.isRequestPending) return;
                
                const type = document.getElementById('add-layer-type').value;
                const newLayer = {
                    id: `layer_${Date.now()}`,
                    type: type,
                    params: {}
                };

                const lastLayer = state.architecture.layers[state.architecture.layers.length - 1];
                const nextIn = lastLayer 
                    ? (lastLayer.params.out_features || lastLayer.params.normalized_shape || 784)
                    : 784;

                if (type === 'Linear') {
                    newLayer.params = { in_features: nextIn, out_features: 64 };
                } else if (type === 'LayerNorm') {
                    newLayer.params = { normalized_shape: nextIn };
                }

                state.architecture.layers.push(newLayer);
                this.renderAll();
                this.log(`Added ${type} layer`, 'info');
            },

            removeLayer(id) {
                if (state.isRequestPending) return;
                state.architecture.layers = state.architecture.layers.filter(l => l.id !== id);
                this.renderAll();
                this.log('Layer removed', 'info');
            },

            updateLayerParam(id, paramName, value) {
                if (state.isRequestPending) return;
                
                const layer = state.architecture.layers.find(l => l.id === id);
                if (!layer) return;

                const numValue = parseInt(value, 10) || 0;
                layer.params[paramName] = numValue;

                const currentIndex = state.architecture.layers.findIndex(l => l.id === id);
                if (layer.type === 'Linear' && paramName === 'out_features') {
                    if (currentIndex + 1 < state.architecture.layers.length) {
                        const nextLayer = state.architecture.layers[currentIndex + 1];
                        if (nextLayer.type === 'Linear') {
                            nextLayer.params.in_features = numValue;
                        } else if (nextLayer.type === 'LayerNorm') {
                            nextLayer.params.normalized_shape = numValue;
                        }
                    }
                }

                this.renderAll();
            },

            loadTemplate(type) {
                if (state.isRequestPending) return;

                const templates = {
                    mlp: [
                        { type: 'Linear', params: { in_features: 784, out_features: 128 } },
                        { type: 'ReLU' },
                        { type: 'Linear', params: { in_features: 128, out_features: 64 } },
                        { type: 'ReLU' },
                        { type: 'Linear', params: { in_features: 64, out_features: 10 } }
                    ],
                    autoencoder: [
                        { type: 'Linear', params: { in_features: 784, out_features: 128 } },
                        { type: 'ReLU' },
                        { type: 'Linear', params: { in_features: 128, out_features: 32 } },
                        { type: 'ReLU' },
                        { type: 'Linear', params: { in_features: 32, out_features: 128 } },
                        { type: 'ReLU' },
                        { type: 'Linear', params: { in_features: 128, out_features: 784 } }
                    ],
                    transformer_block: [
                        { type: 'LayerNorm', params: { normalized_shape: 512 } },
                        { type: 'Linear', params: { in_features: 512, out_features: 512 } },
                        { type: 'LayerNorm', params: { normalized_shape: 512 } },
                        { type: 'Linear', params: { in_features: 512, out_features: 2048 } },
                        { type: 'Gelu' },
                        { type: 'Linear', params: { in_features: 2048, out_features: 512 } }
                    ]
                };

                state.architecture.layers = templates[type].map(l => ({
                    ...l,
                    params: l.params || {},
                    id: `layer_${Date.now()}_${Math.random()}`
                }));

                this.renderAll();
                this.log(`Loaded ${type.toUpperCase()} template`, 'info');
            },

            async createModel() {
                if (state.isRequestPending) return;

                const configText = document.getElementById('model-config').value;
                if (!configText) {
                    this.showStatus('Architecture is empty', 'error', 3000);
                    return;
                }

                let config;
                try {
                    config = JSON.parse(configText);
                } catch (e) {
                    this.showStatus(`Invalid JSON: ${e.message}`, 'error', 5000);
                    return;
                }

                for (const key in config.nodes) {
                    const node = config.nodes[key];
                    if (node.op === 'Linear') {
                        const inF = node.params?.in_features;
                        const outF = node.params?.out_features;
                        if (!inF || !outF || inF <= 0 || outF <= 0) {
                            this.showStatus(`Layer '${key}' has invalid dimensions`, 'error', 5000);
                            return;
                        }
                    }
                    if (node.op === 'LayerNorm') {
                        const shape = node.params?.normalized_shape;
                        if (!shape || shape <= 0) {
                            this.showStatus(`LayerNorm '${key}' has invalid shape`, 'error', 5000);
                            return;
                        }
                    }
                }

                state.isRequestPending = true;
                this.updateButtonStates();
                this.showStatus('Creating model...', 'info', 0);

                try {
                    const response = await fetch(`${API_BASE}/models`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ graph: config })
                    });

                    const result = await response.json();

                    if (response.ok) {
                        this.log(`Model created: ${result.data.model_id.substring(0, 8)}...`, 'success');
                        this.showStatus(result.message, 'success', 5000);
                        await this.updateAvailableModels();
                    } else {
                        throw new Error(result.message || 'Model creation failed');
                    }
                } catch (error) {
                    this.log(`Failed to create model: ${error.message}`, 'error');
                    this.showStatus(`Error: ${error.message}`, 'error', 10000);
                } finally {
                    state.isRequestPending = false;
                    this.updateButtonStates();
                }
            },

            async updateAvailableModels() {
                try {
                    const response = await fetch(`${API_BASE}/models`);
                    const result = await response.json();
                    
                    if (response.ok) {
                        state.models = result.data.models;
                        this.renderModelSelector();
                        this.log(`Found ${state.models.length} models`, 'info');
                    }
                } catch (error) {
                    this.log(`Could not fetch models: ${error.message}`, 'error');
                }
            },

            async startTraining() {
                if (state.isRequestPending) return;

                const modelId = document.getElementById('selected-model').value;
                if (!modelId) {
                    this.showStatus('Please select a model', 'error', 3000);
                    return;
                }

                state.isRequestPending = true;
                this.updateButtonStates();
                this.showStatus('Starting training...', 'info', 0);

                try {
                    const detailsResponse = await fetch(`${API_BASE}/models/${modelId}`);
                    const detailsResult = await detailsResponse.json();
                    
                    if (!detailsResponse.ok) {
                        throw new Error(detailsResult.message || 'Failed to fetch model details');
                    }

                    const arch = detailsResult.data.architecture;
                    const firstNode = Object.values(arch.nodes).find(n => 
                        n.inputs.includes(arch.inputs[0])
                    );
                    const lastNode = arch.nodes[arch.output_node];

                    const inFeatures = firstNode?.op === 'Linear' ? firstNode.params.in_features : 784;
                    const outFeatures = lastNode?.op === 'Linear' ? lastNode.params.out_features : 10;

                    const payload = {
                        x_train: Array.from({ length: 100 }, () => 
                            Array.from({ length: inFeatures }, () => Math.random())
                        ),
                        y_train: Array.from({ length: 100 }, () => 
                            Array.from({ length: outFeatures }, () => Math.random())
                        ),
                        loss: "MSE",
                        optimizer: { 
                            SGD: { lr: parseFloat(document.getElementById('learning-rate').value) }
                        },
                        epochs: parseInt(document.getElementById('epochs').value),
                        batch_size: parseInt(document.getElementById('batch-size').value)
                    };

                    this.log('Training initiated...', 'info');

                    const trainResponse = await fetch(`${API_BASE}/models/${modelId}/train`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const trainResult = await trainResponse.json();

                    if (trainResponse.ok) {
                        this.renderLossGraph(trainResult.data.loss_history);
                        this.log('Training complete!', 'success');
                        this.showStatus('Training completed successfully', 'success', 5000);
                    } else {
                        throw new Error(trainResult.message || 'Training failed');
                    }
                } catch (error) {
                    this.log(`Training failed: ${error.message}`, 'error');
                    this.showStatus(`Training error: ${error.message}`, 'error', 10000);
                } finally {
                    state.isRequestPending = false;
                    this.updateButtonStates();
                }
            },

            renderAll() {
                this.renderLayerList();
                this.renderModelConfig();
                this.renderGraphVisualization();
                this.updateButtonStates();
            },

            renderLayerList() {
                const container = document.getElementById('layer-list');
                if (state.architecture.layers.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-muted); text-align: center;">No layers added yet</p>';
                    return;
                }

                container.innerHTML = state.architecture.layers.map(layer => {
                    let paramsHtml = '';
                    if (layer.type === 'Linear') {
                        paramsHtml = `
                            <input type="number" value="${layer.params.in_features}" 
                                   onchange="app.updateLayerParam('${layer.id}', 'in_features', this.value)">
                            <span>â†’</span>
                            <input type="number" value="${layer.params.out_features}" 
                                   onchange="app.updateLayerParam('${layer.id}', 'out_features', this.value)">
                        `;
                    } else if (layer.type === 'LayerNorm') {
                        paramsHtml = `
                            <span>Shape:</span>
                            <input type="number" value="${layer.params.normalized_shape}" 
                                   onchange="app.updateLayerParam('${layer.id}', 'normalized_shape', this.value)">
                        `;
                    }

                    return `
                        <div class="layer-item">
                            <div class="layer-info">
                                <div class="layer-name">${layer.type}</div>
                                <div class="layer-params">${paramsHtml}</div>
                            </div>
                            <button class="remove-btn" onclick="app.removeLayer('${layer.id}')">Ã—</button>
                        </div>
                    `;
                }).join('');
            },

            renderModelConfig() {
                const { layers } = state.architecture;
                const textarea = document.getElementById('model-config');

                if (layers.length === 0) {
                    textarea.value = '';
                    return;
                }

                const graph = {
                    inputs: ["input"],
                    output_node: layers[layers.length - 1].id,
                    nodes: {}
                };

                layers.forEach((layer, index) => {
                    const node = {
                        op: layer.type,
                        inputs: [index === 0 ? "input" : layers[index - 1].id]
                    };
                    if (Object.keys(layer.params).length > 0) {
                        node.params = layer.params;
                    }
                    graph.nodes[layer.id] = node;
                });

                textarea.value = JSON.stringify(graph, null, 2);
            },

            renderGraphVisualization() {
                const container = document.getElementById('graph-nodes');
                if (state.architecture.layers.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-muted);">Add layers to visualize</p>';
                    return;
                }

                container.innerHTML = state.architecture.layers.map(layer => {
                    let details = '';
                    if (layer.type === 'Linear') {
                        details = `${layer.params.in_features} â†’ ${layer.params.out_features}`;
                    } else if (layer.type === 'LayerNorm') {
                        details = `Shape: ${layer.params.normalized_shape}`;
                    } else {
                        details = 'Activation';
                    }

                    return `<div class="graph-node"><strong>${layer.type}</strong><br><small>${details}</small></div>`;
                }).join('<div class="node-connector"></div>');
            },

            renderModelSelector() {
                const selector = document.getElementById('selected-model');
                selector.innerHTML = state.models.length
                    ? state.models.map(id => 
                        `<option value="${id}">Model: ${id.substring(0, 8)}...</option>`
                      ).join('')
                    : '<option value="">No models available</option>';
            },

            updateButtonStates() {
                document.getElementById('create-model-btn').disabled = state.isRequestPending;
                document.getElementById('train-btn').disabled = state.isRequestPending || state.models.length === 0;
            },

            showStatus(message, type = 'info', duration = 3000) {
                const statusBar = document.getElementById('status-bar');
                const statusText = document.getElementById('status-text');

                statusText.textContent = message;
                statusBar.className = `status-bar ${type}`;

                if (duration > 0) {
                    setTimeout(() => {
                        statusBar.className = 'status-bar';
                        statusText.textContent = 'Ready';
                    }, duration);
                }
            },

            log(message, type = 'info') {
                const logs = document.getElementById('logs');
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `[${timestamp}] ${message}`;
                logs.appendChild(entry);
                logs.scrollTop = logs.scrollHeight;
            },

            renderLossGraph(lossHistory) {
                const canvas = document.getElementById('loss-graph');
                const ctx = canvas.getContext('2d');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = 200;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (!lossHistory || lossHistory.length < 2) return;

                const maxLoss = Math.max(...lossHistory);
                const minLoss = Math.min(...lossHistory);
                const range = maxLoss - minLoss || 1;
                
                const padding = 20;
                const graphWidth = canvas.width - 2 * padding;
                const graphHeight = canvas.height - 2 * padding;

                ctx.beginPath();
                lossHistory.forEach((loss, i) => {
                    const x = padding + (i / (lossHistory.length - 1)) * graphWidth;
                    const y = padding + graphHeight - ((loss - minLoss) / range) * graphHeight;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#8888a8';
                ctx.font = '12px monospace';
                ctx.fillText(`Max: ${maxLoss.toFixed(4)}`, padding, padding - 5);
                ctx.fillText(`Min: ${minLoss.toFixed(4)}`, padding, canvas.height - 5);
            }
        };

        window.addEventListener('DOMContentLoaded', () => app.initialize());
    </script>
</body>
</html>